{"version":3,"sources":["work.js"],"names":["Gear","x","y","fullRadius","angle","direction","speed","color","stroke","blur","arguments","length","undefined","_classCallCheck","this","canvas","document","createElement","radius","context","getContext","draw","width","height","filter","innerRadius","centerX","centerY","fillStyle","beginPath","increment","TWO_PI","slope_width","currentAngle","leftCornerAngle","leftTopCornerAngle","rightCornerAngle","rightTopCornerAngle","Math","cos","spoke_width","lineTo","closePath","GearField","Object","assign","gears","translate","gear","rotate","drawImage","g","dt","scrollDiff","_this","forEach","_this2","dx","radii","drawGear","dy","lastGear","gearCount","floor","random","overlap","attemptCount","nextGearAngle","newX","newY","sin","newAngle","findAnyOverlappingGear","addGear","MID_COLOR","LIGHT_COLOR","newGear","startX","startY","GEAR_SPEED","buildMeshFromGear","buildMesh","DARK_COLOR","a","b","colors","indexOf","gearFields","findOverlappingGear","getElementById","RENDER_WIDTH","RENDER_HEIGHT","PI","scale","lastUpdateTime","lastScrollPosition","window","scrollY","primaryGearCanvas","primaryGearContext","PRIMARY_GEAR_SIZE","requestAnimationFrame","animate","time","primaryGearContainer","primaryGearField","field","primaryGear","restore","QUAD_SIZE","setCanvasToWindowSize","save","getBoundingClientRect","box","_loop","_loop2","quadY","find","f","quadX","primaryBox","masthead","scrollToCurrentHash","hash","location","matchingAnchor","querySelector","rect","headerRect","targetOffset","pageYOffset","top","addEventListener"],"mappings":"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","file":"work.js","sourcesContent":["class Gear {\n  constructor(x, y, fullRadius, angle, direction, speed, color, stroke, blur=true) {\n    this.canvas = document.createElement(\"canvas\");\n\n    this.radius = fullRadius;\n\n    this.context = this.canvas.getContext(\"2d\");\n\n    this.x = x;\n    this.y = y;\n\n    this.angle = angle;\n    this.direction = direction;\n    this.speed = speed;\n\n    this.color = color;\n    this.stroke = stroke;\n\n    this.blur = blur;\n\n    this.draw();\n  }\n  draw() {\n    this.canvas.width = this.radius * 2;\n    this.canvas.height = this.radius * 2;\n\n    if(this.blur) {\n      this.context.filter = \"blur(0.2em)\";\n    }\n\n    let innerRadius = this.radius * 0.8;\n    \n    const centerX = this.canvas.width / 2;\n    const centerY = this.canvas.height / 2;\n    \n    this.context.fillStyle = this.color;\n    this.context.beginPath();\n    \n    let increment = TWO_PI / 10;\n    \n    const spoke_width = increment / 2;\n    \n    const slope_width = spoke_width / 2;\n    \n    for(let currentAngle = 0; currentAngle < TWO_PI; currentAngle += increment) {\n      let leftTopCornerAngle = currentAngle - slope_width * 0.75;\n      let rightTopCornerAngle = currentAngle + slope_width * 0.75;\n      \n      let leftCornerAngle = leftTopCornerAngle - slope_width * 0.5;\n      let rightCornerAngle = rightTopCornerAngle + slope_width * 0.5;\n      \n      this.context.lineTo(\n        centerX + Math.cos(leftCornerAngle) * innerRadius,\n        centerY + Math.sin(leftCornerAngle) * innerRadius\n      );\n      this.context.lineTo(\n        centerX + Math.cos(leftTopCornerAngle) * this.radius,\n        centerY + Math.sin(leftTopCornerAngle) * this.radius\n      );\n      this.context.lineTo(\n        centerX + Math.cos(rightTopCornerAngle) * this.radius,\n        centerY + Math.sin(rightTopCornerAngle) * this.radius\n      );\n      this.context.lineTo(\n        centerX + Math.cos(rightCornerAngle) * innerRadius,\n        centerY + Math.sin(rightCornerAngle) * innerRadius\n      );\n    }\n    \n    this.context.closePath();\n    this.context.fill();\n    if(this.stroke) {\n      this.context.strokeStyle = this.stroke;\n      this.context.stroke();\n    }\n  }\n}\nclass GearField {\n  constructor(context, x, y, width, height) {\n    this.context = context;\n    \n    Object.assign(this, {x, y, width, height});\n    \n    this.gears = [];\n  }\n  \n  drawGear(gear) {\n    this.context.translate(gear.x, gear.y);\n    this.context.rotate(gear.angle);\n    this.context.translate(-gear.radius, -gear.radius);\n    this.context.drawImage(gear.canvas, 0, 0);\n    this.context.translate(gear.radius, gear.radius);\n    this.context.rotate(-gear.angle);\n    this.context.translate(-gear.x, -gear.y);\n  }\n\n  \n  addGear(x, y, radius, angle, direction, speed, color) {\n    let g = new Gear(x, y, radius, angle, direction, speed, color);\n    this.gears.push(g);\n    return g;\n  }\n  \n  draw(dt, scrollDiff) {\n    this.context.translate(this.x, this.y);\n    this.gears.forEach(gear => {\n      gear.angle += gear.speed * scrollDiff * gear.direction;\n      this.drawGear(gear);\n    });\n    this.context.translate(-this.x, -this.y);\n  }\n  \n  findOverlappingGear(x, y, radius, color) {\n    let overlap = this.gears.find(gear => {\n      if(gear.color !== color) {\n        return false;\n      }\n      let dx = (this.x + gear.x) - x;\n      let dy = (this.y + gear.y) - y;\n      let radii = gear.radius + radius;\n      \n      return (dx * dx) + (dy * dy) < radii * radii;\n    });\n    return overlap;\n  }\n  buildMeshFromGear(lastGear) {\n    let gearCount = 1 + Math.floor(Math.random() * 2);\n    \n    let radius = lastGear.radius;\n    let color = lastGear.color;\n    \n    let attemptCount = 0;\n    \n    while(gearCount > 0) {\n      attemptCount++;\n      let nextGearAngle = Math.floor(Math.random() * 10) * TWO_PI / 10;\n      let newX = lastGear.x + Math.cos(nextGearAngle) * radius * 1.85;\n      let newY = lastGear.y + Math.sin(nextGearAngle) * radius * 1.85;\n      \n      let newAngle = lastGear.angle + TWO_PI / 10 / 2;\n      if(newX < this.width && newY < this.height && newX > 0 && newY > 0 && !findAnyOverlappingGear(this.x + newX, this.y + newY, radius * 0.8, color)) {\n        attemptCount = 0;\n        gearCount--;\n        lastGear = this.addGear(newX, newY, radius, newAngle, lastGear.direction * -1, lastGear.speed, color);\n        if(color === MID_COLOR && Math.random() < 0.3) {\n          let newGear = this.addGear(lastGear.x, lastGear.y, lastGear.radius / 2, lastGear.angle, lastGear.direction, lastGear.speed, LIGHT_COLOR);\n          this.buildMeshFromGear(newGear);\n        }\n      }\n      if(attemptCount > 20) {\n        // bailing out\n        return;\n      }\n    } \n  }\n  buildMesh(color) {\n    let startX = Math.random() * this.width;\n    let startY = Math.random() * this.height;\n    \n    let radius = 150;\n    if(color === DARK_COLOR) {\n      radius = 200;\n    }\n    \n    if(color === LIGHT_COLOR) {\n      radius = 60;\n    }\n    \n    let lastGear = {x: startX, y: startY, radius, angle: 0, direction: 1, speed: GEAR_SPEED, color};\n    \n    this.buildMeshFromGear(lastGear)\n  }\n  \n  generate() {\n    this.buildMesh(DARK_COLOR);\n    this.buildMesh(DARK_COLOR);\n    this.buildMesh(MID_COLOR);\n    this.buildMesh(MID_COLOR);\n    this.buildMesh(LIGHT_COLOR);\n    \n    this.gears.sort((a, b) => {\n      return colors.indexOf(a.color) - colors.indexOf(b.color);\n    })\n  }\n}\n\nfunction findAnyOverlappingGear(x, y, radius, color) {\n  return gearFields.find(g => g.findOverlappingGear(x, y, radius, color));\n}\n\nlet canvas = document.getElementById(\"gears\");\n\nlet context = canvas.getContext(\"2d\");\n\nconst LIGHT_COLOR = \"#ffffff\";\nconst MID_COLOR = \"#ccece7\";\nconst DARK_COLOR = \"#25655a\";\n\nconst colors = [DARK_COLOR, MID_COLOR, LIGHT_COLOR];\n\nconst RENDER_WIDTH = 1500;\nconst RENDER_HEIGHT = 700;\n\nconst TWO_PI = Math.PI * 2;\n\nconst GEAR_SPEED = 0.0020;\n\nlet scale = 1;\n\nlet gearFields = [];\n\nlet lastUpdateTime = null;\n\nlet lastScrollPosition = window.scrollY;\n\nlet PRIMARY_GEAR_SIZE = 200;\n\nconst primaryGearContainer = document.getElementById(\"primaryGearContainer\");\nconst primaryGearCanvas = document.getElementById(\"primaryGears\");\nconst primaryGearContext = primaryGearCanvas.getContext(\"2d\");\nconst primaryGearField = new GearField(primaryGearContext, 0, 0, 0, 0);\nconst primaryGear = new Gear(0, 0, PRIMARY_GEAR_SIZE / 2, 0, -1, GEAR_SPEED, MID_COLOR, DARK_COLOR, false);\n\nfunction animate(time) {\n  requestAnimationFrame(animate);\n  \n  if(lastUpdateTime === null) {\n    lastUpdateTime = time;\n  }\n  let dt = time - lastUpdateTime;\n  \n  if(dt > 16) {\n    dt = 16;\n  }\n\n  let scrollDiff = window.scrollY - lastScrollPosition;\n  lastScrollPosition = window.scrollY;\n  \n  \n  if(scrollDiff !== 0 && lastScrollPosition < 460) { // don't re-render if unneeded\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    \n    context.save();\n    context.scale(scale, scale);\n\n    gearFields.forEach(field => {\n      field.draw(dt, scrollDiff);\n    });\n\n    primaryGear.angle += scrollDiff * GEAR_SPEED;\n    primaryGearCanvas.width = PRIMARY_GEAR_SIZE;\n    primaryGearCanvas.height = PRIMARY_GEAR_SIZE;\n    primaryGear.x = PRIMARY_GEAR_SIZE / 2;\n    primaryGear.y = PRIMARY_GEAR_SIZE / 2;\n    primaryGearField.drawGear(primaryGear);\n    \n    context.restore();\n  }\n  \n  \n  lastUpdateTime = time;\n\n}\n\nconst QUAD_SIZE = 600;\n\nfunction setCanvasToWindowSize() {\n  let box = masthead.getBoundingClientRect();\n  canvas.width = box.width;\n  canvas.height = box.height;\n  \n  for(let quadX = 0; quadX < canvas.width / QUAD_SIZE; quadX++) {\n    for(let quadY = 0; quadY < canvas.height / QUAD_SIZE; quadY++) {\n      let existingQuad = gearFields.find(f => f.x === quadX * QUAD_SIZE && f.y === quadY * QUAD_SIZE);\n      if(!existingQuad) {\n        let g = new GearField(context, quadX * QUAD_SIZE, quadY * QUAD_SIZE, QUAD_SIZE, QUAD_SIZE);\n        gearFields.push(g);\n        g.generate();\n      }\n    }\n  }\n\n  let primaryBox = primaryGearContainer.getBoundingClientRect();\n  PRIMARY_GEAR_SIZE = primaryBox.width;\n\n  gearFields.forEach(field => {\n    field.draw(0, 0);\n  });\n\n  primaryGearCanvas.width = PRIMARY_GEAR_SIZE;\n  primaryGearCanvas.height = PRIMARY_GEAR_SIZE;\n  primaryGear.x = PRIMARY_GEAR_SIZE / 2;\n  primaryGear.y = PRIMARY_GEAR_SIZE / 2;\n\n  primaryGear.radius = PRIMARY_GEAR_SIZE / 2;\n  primaryGear.draw();\n\n  primaryGearField.drawGear(primaryGear);\n}\n\nsetCanvasToWindowSize();\nwindow.addEventListener(\"resize\", setCanvasToWindowSize);\n\nrequestAnimationFrame(animate);\n\n\n// adjust anchor offset to account for floating header\nfunction scrollToCurrentHash() {\n  let hash = window.location.hash;\n  let matchingAnchor = document.querySelector(hash);\n  if(matchingAnchor) {\n    let rect = matchingAnchor.getBoundingClientRect();\n    let headerRect = document.querySelector(\"header\").getBoundingClientRect();\n    let targetOffset = window.pageYOffset + rect.top - headerRect.height;\n\n    window.scrollTo(window.pageXOffset, targetOffset);\n  }\n}\n\nwindow.addEventListener(\"load\", scrollToCurrentHash);\nwindow.addEventListener('hashChange', scrollToCurrentHash);"]}